<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>iternal</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">iternal</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
			</ul>
			<h1> iternal</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="iternal">iternal</h1>
				<p>Provides a powerful API for native ES6 iterables and async iterables.</p>
				<h2 id="installation">Installation</h2>
				<p><code>yarn add iternal</code></p>
				<h2 id="api-documentation">API Documentation</h2>
				<p>Generated by Typedoc:
				<a href="https://vitoke.github.io/iternal/globals.html">https://vitoke.github.io/iternal/globals.html</a></p>
				<h2 id="usage">Usage</h2>
				<h3 id="simple">Simple</h3>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> iter <span class="hljs-keyword">from</span> <span class="hljs-string">'iternal'</span>

<span class="hljs-built_in">console</span>.log(
  iter.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)
    .map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * <span class="hljs-number">2</span>)
    .repeat(<span class="hljs-number">2</span>)
    .toArray()
)

&gt; result: [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>]


<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'The min and max value: '</span>,
  iter([<span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>]).collect(iter.ops.range)
)

&gt; result: The min and max value:  [ <span class="hljs-number">3</span>, <span class="hljs-number">10</span> ]


<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'Average word length:'</span>,
  iter([<span class="hljs-string">'This'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'test'</span>])
    .collect(
      iter.ops.average.mapInput(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
    )
)

&gt; result: Average word length: <span class="hljs-number">2.75</span></code></pre>
				<h3 id="advanced">Advanced</h3>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> iter <span class="hljs-keyword">from</span> <span class="hljs-string">'iternal'</span>

<span class="hljs-comment">// rangeBy returns the values for which the function gives the minimum and maximum value</span>
<span class="hljs-keyword">const</span> shortestAndLongestStringCollector = iter.ops.rangeBy&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.length)

<span class="hljs-comment">// mapInput converts some input type into a type the collector understands</span>
<span class="hljs-keyword">const</span> averageStringLengthCollector = iter.ops.average.mapInput&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.length)

<span class="hljs-comment">// We construct a string from the combination of the above two collectors</span>
<span class="hljs-keyword">const</span> verySpecificCollector = iter.collector.combineWith(
  <span class="hljs-function">(<span class="hljs-params">[shortest, longest], avgLen</span>) =&gt;</span>
    <span class="hljs-string">`Shortest word: <span class="hljs-subst">${shortest}</span>, longest word: <span class="hljs-subst">${longest}</span>, average length: <span class="hljs-subst">${avgLen}</span>`</span>,
  shortestAndLongestStringCollector,
  averageStringLengthCollector
)

<span class="hljs-comment">// We create an Iter iterable from a string split</span>
<span class="hljs-keyword">const</span> words = iter(<span class="hljs-string">'This is a very normal sentence'</span>.split(<span class="hljs-string">' '</span>))

<span class="hljs-comment">// Get the final result at once</span>
<span class="hljs-built_in">console</span>.log(words.collect(verySpecificCollector))

&gt; result: Shortest word: a, longest word: sentence, average length: <span class="hljs-number">4.166666666666666</span>

<span class="hljs-comment">// Get the results for each new word</span>
words.collectIter(verySpecificCollector).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))

&gt; result:
Shortest word: This, longest word: This, average length: <span class="hljs-number">4</span>
Shortest word: is, longest word: This, average length: <span class="hljs-number">3</span>
Shortest word: a, longest word: This, average length: <span class="hljs-number">2.3333333333333335</span>
Shortest word: a, longest word: This, average length: <span class="hljs-number">2.75</span>
Shortest word: a, longest word: normal, average length: <span class="hljs-number">3.4</span>
Shortest word: a, longest word: sentence, average length: <span class="hljs-number">4.166666666666666</span></code></pre>
				<h2 id="motivation">Motivation</h2>
				<p>ES6 Iterables are awesome, but miss some basic functionality that e.g. Arrays have, like <code>.map</code> and
				<code>.filter</code>.</p>
				<p>At the same time, Iterables in some ways are more powerful than Arrays, in that they can represent infinite data
					because by nature they are lazy. This means that each next element is evaluated only when requested. The drawback
					compared to Arrays is that Iterables are not indexed, so getting the nth element requires iterating over all n
				elements.</p>
				<h3 id="why-then-are-iterables-so-great-">Why then are Iterables so great?</h3>
				<ol>
					<li><p>Iterables can be combined lazily, without needing to create intermediate structures.
							Imagine that you have 2 or more large arrays of data, and you want to perform some calculation over all of them.
							Normally you can choose either to copy all data into one large array and perform the calculation over this array,
							or you can write a function that takes an array and returns an intermediate value, and then combine the results
							of all the arrays. Using Iterables, you can concatenate the arrays, creating a &#39;virtual&#39; large array without actually
							copying data. Then, you can define a Collector that calculates over all the arrays at once without needing to
						combine intermediate results.</p>
					</li>
					<li><p>Iterables can be edited without actually creating an in-memory copied data structure. This means you can arbitrarily
							insert or remove elements at certain positions, you can map and filter the elements without doing anything in memory.
						You are basically creating imaginary structures that only materialize once you start iterating over the structure.</p>
					</li>
					<li><p>As mentioned before, Iterables can represent infinite data. For example, <code>iter.nats</code> represents all natural integers
							starting for 0. As long as you are not evaluating (e.g. collecting, or performing <code>.forEach()</code>) an infinite Iterable,
						you can safely use them in your code. They are very convenient for use cases like zipping or taking a limited amout.</p>
					</li>
				</ol>
				<h3 id="iterables-vs-iterators">Iterables vs Iterators</h3>
				<p><code>iternal</code> does its best to stick to only the <code>(Async)Iterable</code> interfaces, and keep the <code>(Async)Iterators</code> under the surface.</p>
				<p>Why?</p>
				<p><code>Iterables</code> are predictable and should in principle result in the same values every time an iterable is iterated over.
					On the contrast, <code>Iterators</code> have a hidden state, meaning that they can be partially consumed. This can have undesired effects, since using the same <code>Iterator</code> multiple times can give different results. Except for Iterables that depend on impure inputs
					(like e.g. <code>iter.randomInt()</code>), <code>Iterables</code> should always return the same values. This keeps code functional, pure, and
				thus predictable.</p>
				<p>The result is that <code>Iter</code> and <code>AsyncIter</code> provide a predicable and pure functional API on top of Iterables.</p>
				<h2 id="collect-your-results">Collect your results</h2>
				<p>A Collector is a very powerful concept, present in languages like Java. It is related to
				Reducers, which since React have become more popular.</p>
				<p>A Collector specifies a start state, and a combination function taking some element, and producing a new state. This makes
					a Collector very similar to a <code>for</code> loop. Most <code>for</code> loops start with some initial values, then loop over something iterable,
					while modifying the initial values, and, once the iterable is done, return some results based on the final state of the
				variables.</p>
				<p>However, because, in contrast to a <code>for</code> loop, a Collector is just an object, it can be re-used and composed. This means that,
					once you have written a Collector, you can use it on any iterable object, and you can compose it with other Collectors that
				will run in &#39;parallel&#39;. This is impossible using basic <code>for</code> loops. That&#39;s a major boost to re-usable components.</p>
				<p>Let&#39;s take some examples:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of array) sum += value
  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProduct</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> product = <span class="hljs-number">1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of array) product *= value
  <span class="hljs-keyword">return</span> product
}</code></pre>
				<p>Here we have written 2 functions that can get the sum and product of an array of integers. But what if we want both?
					We can write something like <code>const [sum, product] = [getSum(someArray), getProduct(someArray)]</code> but this will process
					the array twice. That should not be necessary. The only way to do it in the above way is to write a new function that
				loops over the array once and calculates both results at once.</p>
				<p>Now, using Collectors:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// already defined as iter.ops.sum</span>
<span class="hljs-keyword">const</span> sumCollector = iter.collector.create({ init: <span class="hljs-number">0</span>, next: <span class="hljs-function">(<span class="hljs-params">state, value</span>) =&gt;</span> state + value })

<span class="hljs-comment">// already defined as iter.ops.product</span>
<span class="hljs-keyword">const</span> productCollector = iter.collector.create({ init: <span class="hljs-number">1</span>, next: <span class="hljs-function">(<span class="hljs-params">state, value</span>) =&gt;</span> state * value })

<span class="hljs-keyword">const</span> [sum, product] = iter(someArray).collect(
  iter.collector.combine(sumCollector, productCollector)
)</code></pre>
				<p>Now that we have written these Collectors, we can also reuse the logic in many different ways. Imagine that we want
					to calculate the sum of all lengths of words in an array. We cannot directly use the <code>sumCollector</code> defined above,
					since it doesn&#39;t handle strings as input. Instead of converting our array of strings to an array with the lengths of the
				words, we can modify the our Collect to do this input conversion &#39;on the fly&#39;:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> wordLengthSum = sumCollector.mapInput&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)

<span class="hljs-keyword">const</span> totalLength = iter(arrayOfStrings, someOtherArrayOfStrings).collect(wordLengthSum)</code></pre>
				<p>And again, we can use <code>Collector.combine</code> if we want to get multiple results for the array:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> wordLengthAverage = iter.ops.average.mapInput&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)

<span class="hljs-keyword">const</span> [totalLength, averageLength] = iter(arrayOfStrings).collect(
  iter.collector.combine(wordLengthSum, wordLengthAverage)
)</code></pre>
				<p><code>iternal</code> even defines many input modifiers for Collectors that help modifying the input, for exampe:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> aCollector = iter.ops.average
  .mapInput&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
  .sampleInput(<span class="hljs-number">2</span>)
  .dropInput(<span class="hljs-number">1</span>)
  .appendInput(<span class="hljs-string">'test'</span>, <span class="hljs-string">'foo'</span>)
  .filterInput(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length &gt; <span class="hljs-number">2</span>)</code></pre>
				<p>This collector will take the average word lengths of the input words, where the input is modified as follows:</p>
				<ul>
					<li><code>mapInput</code> indicates that strings are taken as input, but the length is taken for the average collector</li>
					<li><code>filterInput</code> removes all words with length less than 3</li>
					<li><code>appendInput</code> adds the words &#39;test&#39; and &#39;foo&#39; to the end of the input</li>
					<li><code>dropInput</code> skips the first input word</li>
					<li><code>sampleInput</code> takes every 2nd word of the input</li>
				</ul>
				<p>It is interesting to note here that, as the list indicates, most of these operations should be read in backward order, since we are transforming a given input stream towards our desired input stream.</p>
				<p>Hopefully you see that you now probably never have to write a <code>for</code> loop over some Iterable again.</p>
				<h3 id="advanced-topic-more-powerful-and-efficient-collectors">Advanced topic: More powerful and efficient Collectors</h3>
				<p>A collector is very similar to a function called <code>fold</code> or <code>reduce</code> in functional programming. However, it solves some of the
				issues that the functional <code>fold</code> method has. Issues of the <code>fold</code> method compared to a <code>for</code> loop are:</p>
				<ol>
					<li>A functional fold&#39;s state type is also the result type, meaning that the state cannot be some intermediate value from which
					a result is derived.</li>
					<li>A functional fold always has to process all values of the iterable, even if its result can never change regardless of future inputs. This can be inefficient, but also makes it impossible to fold infinite iterables.</li>
					<li>A functional fold cannot use mutable objects in its state, since the object would be reused for every future fold and thus
					cause unwanted side-effects.</li>
				</ol>
				<p>Let&#39;s see how the <code>iternal</code> library solves these three drawbacks.</p>
				<h4 id="intermediate-state">Intermediate state</h4>
				<p>In <code>iternal</code>, you can define a function that maps the collector&#39;s state to a result of a different type. Imagine the following
				<code>for</code> loop:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumIsPrime</span>(<span class="hljs-params">someArray</span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> elem of someArray) value += elem

  <span class="hljs-keyword">return</span> isPrime(value)
}</code></pre>
				<p>As a Collector:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> sumIsPrime: Collector&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>&gt; = iter.collector.createState({
  init: <span class="hljs-number">0</span>,
  next: <span class="hljs-function">(<span class="hljs-params">state, elem</span>) =&gt;</span> state + elem,
  stateToResult: isPrime
})</code></pre>
				<p>You can actually also do this after the fact with an existing Collector:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> sumIsPrime2 = sumCollector.mapResult(isPrime)</code></pre>
				<h4 id="intermediate-return">Intermediate return</h4>
				<p>In <code>iternal</code> you can define an &#39;escape&#39; condition, indicating that the state will never change, and thus iteration can be
				interrupted. Let&#39;s look at the following <code>for</code> loop:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEfficientProduct</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> product = <span class="hljs-number">1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of array) {
    <span class="hljs-comment">// if any value equals 0 the result will always be 0</span>
    <span class="hljs-keyword">if</span> (value === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    product *= value
  }
}</code></pre>
				<p>We can express the <code>return</code> condition in <code>iternal</code> by supplying an <code>escape</code> predicate as follows:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> efficientProduct = iter.collector.create({
  init: <span class="hljs-number">0</span>,
  next: <span class="hljs-function">(<span class="hljs-params">state, value</span>) =&gt;</span> state * value,
  <span class="hljs-built_in">escape</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state === <span class="hljs-number">0</span>
})</code></pre>
				<p>Now, we can run this collector on infinite streams (but only if they somewhere meet the escape condition):</p>
				<pre><code class="language-typescript">iter.range(<span class="hljs-number">-100</span>).collect(efficientProduct)
&gt;&gt; returns <span class="hljs-number">0</span>

<span class="hljs-comment">// We use the 'inefficient' productCollector we defined earlier</span>
iter.range(<span class="hljs-number">-100</span>).collect(productCollector)
&gt;&gt; never returns, since it has no <span class="hljs-built_in">escape</span></code></pre>
				<h4 id="using-mutable-state">Using mutable state</h4>
				<p>Imagine that you need to create some Object from an iterable like the following <code>for</code> loop:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObject</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> object = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key of array) {
    object[key] = <span class="hljs-string">'init'</span>
  }
  <span class="hljs-keyword">return</span> object
}</code></pre>
				<p>Everytime you call this <code>createObject</code> function, you will receive a new object, which is what you expect.</p>
				<p>However, let&#39;s see what happens using a naive Collector:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> createObject = iter.collector.create({
  init: {},
  next: <span class="hljs-function">(<span class="hljs-params">state, key</span>) =&gt;</span> {
    state[key] = <span class="hljs-string">'init'</span>
    <span class="hljs-keyword">return</span> state
  }
})

<span class="hljs-keyword">const</span> result1 = iter([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).collect(createObject)
&gt; result1 = { a: <span class="hljs-string">'init'</span>, b: <span class="hljs-string">'init'</span> }

<span class="hljs-keyword">const</span> result2 = iter([<span class="hljs-string">'c'</span>]).collect(createObject)
&gt; result2 = { a: <span class="hljs-string">'init'</span>, b: <span class="hljs-string">'init'</span>, c: <span class="hljs-string">'init'</span> }</code></pre>
				<p>Ouch, what went wrong here?</p>
				<p>Well, since we specified our Collector as a constant that has some object as its initial state, this object will
				be used across all collect requests, meaning the object will keep collecting new values in this one only object.</p>
				<p>Obviously, that is not desirable.</p>
				<p>To fix such cases, you can optionally provide a constructor function as the initial state. <code>iternal</code> will recognize
				this constructor function, and then create a new object every time the Collector is used:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> fixedCreateObject = iter.collector.create({
  init: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({}),  <span class="hljs-comment">// &lt;-- this line has changed</span>
  next: <span class="hljs-function">(<span class="hljs-params">state, key</span>) =&gt;</span> {
    state[key] = <span class="hljs-string">'init'</span>
    <span class="hljs-keyword">return</span> state
  }
})

<span class="hljs-keyword">const</span> result1 = iter([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).collect(fixedCreateObject)
&gt; result1 = { a: <span class="hljs-string">'init'</span>, b: <span class="hljs-string">'init'</span> }

<span class="hljs-keyword">const</span> result2 = iter([<span class="hljs-string">'c'</span>]).collect(fixedCreateObject)
&gt; result2 = { c: <span class="hljs-string">'init'</span> }</code></pre>
				<h2 id="conclusion">Conclusion</h2>
				<p>I hope to have shown you how powerful and efficient <code>iternal</code> can be as a library, and that it should
				not be needed to ever write a <code>for</code> loop again.</p>
				<p>This quick tutorial only scratches the surface of what is possible, since there is also the <code>AsyncIter</code>
					interface that provides almost the same API as <code>Iter</code> but then for asynchronous iterables. The possibilities
				are literally endless :)</p>
				<h2 id="author">Author</h2>
				<p>Arvid Nicolaas</p>
				<h1 id="have-fun-">Have fun!</h1>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class=" tsd-kind-external-module">
						<a href="globals.html">iternal</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>