<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>iternal</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">iternal</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
			</ul>
			<h1> iternal</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="iternal">iternal</h1>
				<p>Provides a powerful API for native ES6 iterables and async iterables.</p>
				<h2 id="installation">Installation</h2>
				<p><code>yarn add iternal</code></p>
				<h2 id="usage">Usage</h2>
				<h3 id="simple">Simple</h3>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Fold, Folds } <span class="hljs-keyword">from</span> <span class="hljs-string">'iternal'</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The average: '</span>, Fold.fold([<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], Folds.average))

result: The average: <span class="hljs-number">5.25</span></code></pre>
				<h3 id="advanced">Advanced</h3>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Iter, Fold, Folds } <span class="hljs-keyword">from</span> <span class="hljs-string">'iternal'</span>

Iter.randomInt(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
  .repeat()
  .foldIter(Fold.combine(Folds.last(), Folds.sum, Folds.product, Folds.average))
  .map(
    <span class="hljs-function">(<span class="hljs-params">[value, sum, prod, avg]</span>) =&gt;</span>
      <span class="hljs-string">`The latest value is <span class="hljs-subst">${value}</span>. The current sum is <span class="hljs-subst">${sum}</span>, the product <span class="hljs-subst">${prod}</span> and the average <span class="hljs-subst">${avg}</span>`</span>
  )
  .take(<span class="hljs-number">5</span>)
  .forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))

result: (example output)
The latest value is <span class="hljs-number">49.</span> The current sum is <span class="hljs-number">49</span>, the product <span class="hljs-number">49</span> and the average <span class="hljs-number">49</span>
The latest value is <span class="hljs-number">66.</span> The current sum is <span class="hljs-number">115</span>, the product <span class="hljs-number">3234</span> and the average <span class="hljs-number">57.5</span>
The latest value is <span class="hljs-number">3.</span> The current sum is <span class="hljs-number">118</span>, the product <span class="hljs-number">9702</span> and the average <span class="hljs-number">39.33333333333333</span>
The latest value is <span class="hljs-number">54.</span> The current sum is <span class="hljs-number">172</span>, the product <span class="hljs-number">523908</span> and the average <span class="hljs-number">43</span>
The latest value is <span class="hljs-number">99.</span> The current sum is <span class="hljs-number">271</span>, the product <span class="hljs-number">51866892</span> and the average <span class="hljs-number">54.2</span></code></pre>
				<h2 id="motivation">Motivation</h2>
				<p>ES6 Iterables are awesome, but miss some basic functionality that e.g. Arrays have, like <code>.map</code> and
				<code>.filter</code>.</p>
				<p>At the same time, Iterables in some ways are more powerful than Arrays, in that they can represent infinite data
					because by nature they are lazy. This means that each next element is evaluated only when requested. The drawback
					compared to Arrays is that Iterables are not indexed, so getting the nth element requires iterating over all n
				elements.</p>
				<h3 id="why-then-are-iterables-so-great-">Why then are Iterables so great?</h3>
				<ol>
					<li><p>Iterables can be combined lazily, without needing to create intermediate structures.
							Imagine that you have 2 or more large arrays of data, and you want to perform some calculation over all of them.
							Normally you can choose either to copy all data into one large array and perform the calculation over this array,
							or you can write a function that takes an array and returns an intermediate value, and then combine the results
							of all the arrays. Using Iterables, you can concatenate the arrays, creating a &#39;virtual&#39; large array without actually
							copying data. Then, you can define a Fold operation that calculates over all the arrays at once without needing to
						combine intermediate results.</p>
					</li>
					<li><p>Iterables can be edited without actually creating an in-memory copied data structure. This means you can arbitrarily
							insert or remove elements at certain positions, you can map and filter the elements without doing anything in memory.
						You are basically creating imaginary structures that only materialize once you start iterating over the structure.</p>
					</li>
					<li><p>As mentioned before, Iterables can represent infinite data. For example, <code>Iter.nats</code> represents all natural integers
							starting for 0. As long as you are not evaluating (e.g. folding, or performing <code>.forEach()</code>) an infinite Iterable,
						you can safely use them in your code. They are very convenient for use cases like zipping or taking a limited amout.</p>
					</li>
				</ol>
				<h3 id="iterables-vs-iterators">Iterables vs Iterators</h3>
				<p><code>iternal</code> does its best to stick to only the <code>(Async)Iterable</code> interfaces, and keep the <code>(Async)Iterators</code> under the surface.</p>
				<p>Why?</p>
				<p><code>Iterables</code> are predictable and should in principle result in the same values every time an iterable is iterated over.
					On the contrast, <code>Iterators</code> have a hidden state, meaning that they can be partially consumed. This can have undesired effects, since using the same <code>Iterator</code> multiple times can give different results. Except for Iterables that depend on impure inputs
					(like e.g. <code>Iter.randomInt()</code>), <code>Iterables</code> should always return the same values. This keeps code functional, pure, and
				thus predictable.</p>
				<p>The result is that <code>Iter</code> and <code>AsyncIter</code> provide a predicable and pure functional API on top of Iterables.</p>
				<h2 id="use-the-fold">Use the Fold</h2>
				<p>A Fold is a very powerful concept from functional programming that is, in my opinion, underused. It is related to
				Reducers, which since React have become more popular.</p>
				<p>A Fold specifies a start state, and a combination function taking some element, and producing a new state. This makes
					a Fold very similar to a <code>for</code> loop. Most <code>for</code> loops start with some initial values, then loop over something iterable,
					while modifying the initial values, and, once the iterable is done, return some results based on the final state of the
				variables.</p>
				<p>However, because, in contrast to a <code>for</code> loop, a Fold is just an object, it can be re-used and composed. This means that,
					once you have written a Fold object, you can use it on any iterable object, and you can compose it with other Folds that
				will run in &#39;parallel&#39;. This is impossible using basic <code>for</code> loops. That&#39;s a major boost to re-usable components.</p>
				<p>Let&#39;s take some examples:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of array) sum += value
  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProduct</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> product = <span class="hljs-number">1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of array) product *= value
  <span class="hljs-keyword">return</span> product
}</code></pre>
				<p>Here we have written 2 functions that can get the sum and average of an array of integers. But what if we want both?
					We can write something like <code>const [sum, product] = [getSum(someArray), getProduct(someArray)]</code> but this will process
				the array twice. That should not be necessary.</p>
				<p>Now, using Folds:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// already defined as Folds.sum</span>
<span class="hljs-keyword">const</span> sumFolder = MonoFolder.create(<span class="hljs-number">0</span>, <span class="hljs-function">(<span class="hljs-params">state, value</span>) =&gt;</span> state + value)

<span class="hljs-comment">// already defined as Folds.product</span>
<span class="hljs-keyword">const</span> productFolder = MonoFolder.create(<span class="hljs-number">1</span>, <span class="hljs-function">(<span class="hljs-params">state, value</span>) =&gt;</span> state * value)

<span class="hljs-keyword">const</span> [sum, product] = Fold.fold(someArray, Fold.combine(sumFolder, productFolder))</code></pre>
				<p>Here, <code>MonoFolder</code> just means a <code>Folder</code> of which the state type is the same as its input and output type (called
				Monoid in functional programming).</p>
				<p>Now that we have written these Folds, we can also reuse the logic in many different ways. Imagine that we want
					to calculate the sum of all lengths of words in an array. We cannot directly use the <code>sumFold</code> defined above,
					since it doesn&#39;t handle strings. Instead of converting our array of strings to an array with the lengths of the
				words, we can modify the our Fold to do this conversion &#39;on the fly&#39;:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> wordLengthSum = sumFolder.mapInput(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.length)

<span class="hljs-keyword">const</span> totalLength = Fold.fold(arrayOfStrings, wordLengthSum)</code></pre>
				<p>And again, we can use <code>Fold.combine</code> if we want to get multiple results for the array:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> wordLengthAverage = Folds.average.mapInput(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.length)

<span class="hljs-keyword">const</span> [totalLength, averageLength] = Fold.fold(arrayOfStrings, Fold.combine(wordLengthSum, wordLengthAverage)</code></pre>
				<p>Hopefully you see that you now probably never have to write a <code>for</code> loop over some Iterable again.</p>
				<h3 id="advanced-topic-more-powerful-and-efficient-folds">Advanced topic: More powerful and efficient Folds</h3>
				<p>The typical functional fold has the benefits descriped above, but also has a number of drawbacks compared to <code>for</code> loops:</p>
				<ol>
					<li>A functional fold&#39;s state type is also the result type, meaning that the state cannot be some intermediate value from which
					a result is derived.</li>
					<li>A functional fold always has to process all values of the iterable, even if its result can never change regardless of future inputs. This can be inefficient, but also makes it impossible to fold infinite iterables.</li>
					<li>A functional fold cannot use mutable objects in its state, since the object would be reused for every future fold and thus
					cause unwanted side-effects.</li>
				</ol>
				<p>Let&#39;s see how the <code>iternal</code> library solves these three drawbacks.</p>
				<h4 id="intermediate-state">Intermediate state</h4>
				<p>In <code>iternal</code>, you can define a function that maps the folder&#39;s state to a result of a different type. Imagine the following
				<code>for</code> loop:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumIsPrime</span>(<span class="hljs-params">someArray</span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> elem of someArray) value += elem

  <span class="hljs-keyword">return</span> isPrime(value)
}</code></pre>
				<p>As a Folder:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> sumIsPrime = Folder.create(<span class="hljs-number">0</span>, <span class="hljs-function">(<span class="hljs-params">state, elem</span>) =&gt;</span> state + elem, isPrime)</code></pre>
				<p>You can actually also do this after the fact with an existing Folder:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> sumIsPrime2 = sumFolder.mapResult(isPrime)</code></pre>
				<h4 id="intermediate-return">Intermediate return</h4>
				<p>In <code>iternal</code> you can define an &#39;escape&#39; condition, indicating that the state will never change, and thus iteration can be
				interrupted.</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEfficientProduct</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> product = <span class="hljs-number">1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value of array) {
    <span class="hljs-comment">// if any value equals 0 the result will always be 0</span>
    <span class="hljs-keyword">if</span> (value === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    product *= value
  }
}</code></pre>
				<p>We can express the <code>return</code> condition in <code>iternal</code> by supplying an <code>escape</code> predicate as follows:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> efficientProduct = MonoFolder.create(<span class="hljs-number">0</span>, <span class="hljs-function">(<span class="hljs-params">state, value</span>) =&gt;</span> state * value, <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state === <span class="hljs-number">0</span>)</code></pre>
				<p>Now, we can run this folder on infinite streams (but only if they somewhere meet the escape contidion):</p>
				<pre><code class="language-typescript">Iter.range(<span class="hljs-number">-100</span>).fold(efficientProduct)
&gt;&gt; returns <span class="hljs-number">0</span>

Iter.range(<span class="hljs-number">-100</span>).fold(productFolder)
&gt;&gt; never returns</code></pre>
				<h4 id="using-mutable-state">Using mutable state</h4>
				<p>Imagine that you need to create some Object from an iterable like the following <code>for</code> loop:</p>
				<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObject</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">let</span> object = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key of array) {
    object[key] = <span class="hljs-string">'init'</span>
  }
  <span class="hljs-keyword">return</span> object
}</code></pre>
				<p>Everytime you call this <code>createObject</code> function, you will receive a new object, which is what you expect.</p>
				<p>However, let&#39;s see what happens using a naive Folder:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> createObject = Folder.create({}, <span class="hljs-function">(<span class="hljs-params">state, key</span>) =&gt;</span> {
  state[key] = <span class="hljs-string">'init'</span>
  <span class="hljs-keyword">return</span> state
})

<span class="hljs-keyword">const</span> result1 = Fold.fold([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], createObject)
&gt; result1 = { a: <span class="hljs-string">'init'</span>, b: <span class="hljs-string">'init'</span> }

<span class="hljs-keyword">const</span> result2 = Fold.fold([<span class="hljs-string">'c'</span>, createObject])
&gt; result2 = { a: <span class="hljs-string">'init'</span>, b: <span class="hljs-string">'init'</span>, c: <span class="hljs-string">'init'</span> }</code></pre>
				<p>Ouch, what went wrong here?</p>
				<p>Well, since we specified our Folder as a constant that has some object as its initial state, this object will
				be used across all folds, meaning the object will keep collecting new values in this one only object.</p>
				<p>Obviously, that is not desirable.</p>
				<p>To fix such cases, you can optionally provide a constructor function as the initial state. <code>iternal</code> will recognize
				this constructor function, and then create a new object every time the Folder is used:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> fixedCreateObject = Folder.create(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({}), <span class="hljs-function">(<span class="hljs-params">state, key</span>) =&gt;</span> {
  state[key] = <span class="hljs-string">'init'</span>
  <span class="hljs-keyword">return</span> state
})

<span class="hljs-keyword">const</span> result1 = Fold.fold([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], fixedCreateObject)
&gt; result1 = { a: <span class="hljs-string">'init'</span>, b: <span class="hljs-string">'init'</span> }

<span class="hljs-keyword">const</span> result2 = Fold.fold([<span class="hljs-string">'c'</span>, fixedCreateObject])
&gt; result2 = { c: <span class="hljs-string">'init'</span> }</code></pre>
				<h2 id="conclusion">Conclusion</h2>
				<p>I hope to have shown you how powerful and efficient <code>iternal</code> can be as a library, and that it should
				not be needed to ever write a <code>for</code> loop again.</p>
				<p>This quick tutorial only scratches the surface of what is possible, since there is also the <code>AsyncIter</code>
					interface that provides almost the same API as <code>Iter</code> but then for asynchronous iterables. The possibilities
				are literally endless :)</p>
				<h1 id="have-fun-">Have fun!</h1>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class=" tsd-kind-external-module">
						<a href="globals.html">iternal</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>